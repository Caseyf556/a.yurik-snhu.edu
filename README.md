# a.yurik-snhu.edu

1. What was the problem you were solving in the projects for this course?
In the projects for this course, the main problem was to design efficient software solutions by implementing and utilizing various data structures such as arrays, linked lists, stacks, queues, trees, and graphs. Each project presented real-world scenarios—like managing a task list, processing data streams, or finding optimal paths—which required selecting and implementing data structures that best fit the problem’s constraints and requirements.

2. How did you approach the problem? Consider why data structures are important to understand.
I approached each problem by first analyzing the requirements and identifying what operations needed to be efficient (e.g., quick lookup, fast insertion/deletion, or ordered traversal). Understanding data structures was essential because they determine how data is stored, accessed, and manipulated. For example, for fast access and updates, I chose hash tables; for maintaining order, I used trees or linked lists. I wrote out pseudocode, mapped out possible data flows, and selected the most suitable structure before coding.

3. How did you overcome any roadblocks you encountered while going through the activities or project?
Whenever I encountered obstacles—such as unexpected bugs, performance issues, or confusion over implementing a particular data structure—I referred to class resources, documentation, and online tutorials. I also broke down complex problems into smaller components and used print statements or a debugger to trace issues. Collaborating with classmates and asking questions when stuck helped me gain new perspectives and clarify misunderstandings.

4. How has your work on this project expanded your approach to designing software and developing programs?
Working on these projects expanded my approach to software design by making me more intentional about selecting data structures based on problem requirements, rather than defaulting to familiar ones. I became more aware of algorithm efficiency and the trade-offs between different approaches. I now start with a clearer plan and spend more time on design before coding, which leads to more robust and efficient software.

5. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
Through this project, I learned to write cleaner and more modular code by separating concerns, using descriptive variable names, and adding comments where necessary. I prioritized readability and maintainability by breaking code into functions and classes, and by adhering to consistent formatting. I also learned to write adaptable code by considering how future changes or new requirements might be incorporated, such as by using interfaces or abstract classes where appropriate.
